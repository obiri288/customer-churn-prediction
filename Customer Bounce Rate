{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "dd49224b-b75a-4be8-9b64-0c57972c4121",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "   RowNumber  CustomerId   Surname  CreditScore Geography  Gender  Age  \\\n",
      "0          1    15634602  Hargrave          619    France  Female   42   \n",
      "1          2    15647311      Hill          608     Spain  Female   41   \n",
      "2          3    15619304      Onio          502    France  Female   42   \n",
      "3          4    15701354      Boni          699    France  Female   39   \n",
      "4          5    15737888  Mitchell          850     Spain  Female   43   \n",
      "\n",
      "   Tenure    Balance  NumOfProducts  HasCrCard  IsActiveMember  \\\n",
      "0       2       0.00              1          1               1   \n",
      "1       1   83807.86              1          0               1   \n",
      "2       8  159660.80              3          1               0   \n",
      "3       1       0.00              2          0               0   \n",
      "4       2  125510.82              1          1               1   \n",
      "\n",
      "   EstimatedSalary  Exited  Complain  Satisfaction Score Card Type  \\\n",
      "0        101348.88       1         1                   2   DIAMOND   \n",
      "1        112542.58       0         1                   3   DIAMOND   \n",
      "2        113931.57       1         1                   3   DIAMOND   \n",
      "3         93826.63       0         0                   5      GOLD   \n",
      "4         79084.10       0         0                   5      GOLD   \n",
      "\n",
      "   Point Earned  \n",
      "0           464  \n",
      "1           456  \n",
      "2           377  \n",
      "3           350  \n",
      "4           425  \n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "dateipfad = r\"C:\\Users\\TN1\\Downloads\\Customer-Churn-Records.csv\"\n",
    "daten = pd.read_csv(dateipfad)\n",
    "print(daten.head())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "eef50f5a-f415-475d-9acf-d879336e9edc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--- Daten-Info ---\n",
      "<class 'pandas.core.frame.DataFrame'>\n",
      "RangeIndex: 10000 entries, 0 to 9999\n",
      "Data columns (total 18 columns):\n",
      " #   Column              Non-Null Count  Dtype  \n",
      "---  ------              --------------  -----  \n",
      " 0   RowNumber           10000 non-null  int64  \n",
      " 1   CustomerId          10000 non-null  int64  \n",
      " 2   Surname             10000 non-null  object \n",
      " 3   CreditScore         10000 non-null  int64  \n",
      " 4   Geography           10000 non-null  object \n",
      " 5   Gender              10000 non-null  object \n",
      " 6   Age                 10000 non-null  int64  \n",
      " 7   Tenure              10000 non-null  int64  \n",
      " 8   Balance             10000 non-null  float64\n",
      " 9   NumOfProducts       10000 non-null  int64  \n",
      " 10  HasCrCard           10000 non-null  int64  \n",
      " 11  IsActiveMember      10000 non-null  int64  \n",
      " 12  EstimatedSalary     10000 non-null  float64\n",
      " 13  Exited              10000 non-null  int64  \n",
      " 14  Complain            10000 non-null  int64  \n",
      " 15  Satisfaction Score  10000 non-null  int64  \n",
      " 16  Card Type           10000 non-null  object \n",
      " 17  Point Earned        10000 non-null  int64  \n",
      "dtypes: float64(2), int64(12), object(4)\n",
      "memory usage: 1.4+ MB\n",
      "\n",
      "--- Fehlende Werte pro Spalte ---\n",
      "RowNumber             0\n",
      "CustomerId            0\n",
      "Surname               0\n",
      "CreditScore           0\n",
      "Geography             0\n",
      "Gender                0\n",
      "Age                   0\n",
      "Tenure                0\n",
      "Balance               0\n",
      "NumOfProducts         0\n",
      "HasCrCard             0\n",
      "IsActiveMember        0\n",
      "EstimatedSalary       0\n",
      "Exited                0\n",
      "Complain              0\n",
      "Satisfaction Score    0\n",
      "Card Type             0\n",
      "Point Earned          0\n",
      "dtype: int64\n"
     ]
    }
   ],
   "source": [
    "print(\"--- Daten-Info ---\")\n",
    "daten.info()\n",
    "print(\"\\n--- Fehlende Werte pro Spalte ---\")\n",
    "print(daten.isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "c60c379f-7281-4418-b079-333577c9f794",
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyError",
     "evalue": "\"['customerID'] not found in axis\"",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[13], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m daten \u001b[38;5;241m=\u001b[39m daten\u001b[38;5;241m.\u001b[39mdrop(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mcustomerID\u001b[39m\u001b[38;5;124m'\u001b[39m, axis\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m1\u001b[39m)\n\u001b[0;32m      2\u001b[0m daten \u001b[38;5;241m=\u001b[39m daten\u001b[38;5;241m.\u001b[39mdrop(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mRowNumber\u001b[39m\u001b[38;5;124m'\u001b[39m, axis\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m1\u001b[39m)\n\u001b[0;32m      3\u001b[0m daten[\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mTotalCharges\u001b[39m\u001b[38;5;124m'\u001b[39m] \u001b[38;5;241m=\u001b[39m pd\u001b[38;5;241m.\u001b[39mto_numeric(daten[\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mTotalCharges\u001b[39m\u001b[38;5;124m'\u001b[39m], errors\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mcoerce\u001b[39m\u001b[38;5;124m'\u001b[39m)\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\frame.py:5581\u001b[0m, in \u001b[0;36mDataFrame.drop\u001b[1;34m(self, labels, axis, index, columns, level, inplace, errors)\u001b[0m\n\u001b[0;32m   5433\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mdrop\u001b[39m(\n\u001b[0;32m   5434\u001b[0m     \u001b[38;5;28mself\u001b[39m,\n\u001b[0;32m   5435\u001b[0m     labels: IndexLabel \u001b[38;5;241m|\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m,\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m   5442\u001b[0m     errors: IgnoreRaise \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mraise\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m   5443\u001b[0m ) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m DataFrame \u001b[38;5;241m|\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[0;32m   5444\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[0;32m   5445\u001b[0m \u001b[38;5;124;03m    Drop specified labels from rows or columns.\u001b[39;00m\n\u001b[0;32m   5446\u001b[0m \n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m   5579\u001b[0m \u001b[38;5;124;03m            weight  1.0     0.8\u001b[39;00m\n\u001b[0;32m   5580\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n\u001b[1;32m-> 5581\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28msuper\u001b[39m()\u001b[38;5;241m.\u001b[39mdrop(\n\u001b[0;32m   5582\u001b[0m         labels\u001b[38;5;241m=\u001b[39mlabels,\n\u001b[0;32m   5583\u001b[0m         axis\u001b[38;5;241m=\u001b[39maxis,\n\u001b[0;32m   5584\u001b[0m         index\u001b[38;5;241m=\u001b[39mindex,\n\u001b[0;32m   5585\u001b[0m         columns\u001b[38;5;241m=\u001b[39mcolumns,\n\u001b[0;32m   5586\u001b[0m         level\u001b[38;5;241m=\u001b[39mlevel,\n\u001b[0;32m   5587\u001b[0m         inplace\u001b[38;5;241m=\u001b[39minplace,\n\u001b[0;32m   5588\u001b[0m         errors\u001b[38;5;241m=\u001b[39merrors,\n\u001b[0;32m   5589\u001b[0m     )\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\generic.py:4788\u001b[0m, in \u001b[0;36mNDFrame.drop\u001b[1;34m(self, labels, axis, index, columns, level, inplace, errors)\u001b[0m\n\u001b[0;32m   4786\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m axis, labels \u001b[38;5;129;01min\u001b[39;00m axes\u001b[38;5;241m.\u001b[39mitems():\n\u001b[0;32m   4787\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m labels \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[1;32m-> 4788\u001b[0m         obj \u001b[38;5;241m=\u001b[39m obj\u001b[38;5;241m.\u001b[39m_drop_axis(labels, axis, level\u001b[38;5;241m=\u001b[39mlevel, errors\u001b[38;5;241m=\u001b[39merrors)\n\u001b[0;32m   4790\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m inplace:\n\u001b[0;32m   4791\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_update_inplace(obj)\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\generic.py:4830\u001b[0m, in \u001b[0;36mNDFrame._drop_axis\u001b[1;34m(self, labels, axis, level, errors, only_slice)\u001b[0m\n\u001b[0;32m   4828\u001b[0m         new_axis \u001b[38;5;241m=\u001b[39m axis\u001b[38;5;241m.\u001b[39mdrop(labels, level\u001b[38;5;241m=\u001b[39mlevel, errors\u001b[38;5;241m=\u001b[39merrors)\n\u001b[0;32m   4829\u001b[0m     \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m-> 4830\u001b[0m         new_axis \u001b[38;5;241m=\u001b[39m axis\u001b[38;5;241m.\u001b[39mdrop(labels, errors\u001b[38;5;241m=\u001b[39merrors)\n\u001b[0;32m   4831\u001b[0m     indexer \u001b[38;5;241m=\u001b[39m axis\u001b[38;5;241m.\u001b[39mget_indexer(new_axis)\n\u001b[0;32m   4833\u001b[0m \u001b[38;5;66;03m# Case for non-unique axis\u001b[39;00m\n\u001b[0;32m   4834\u001b[0m \u001b[38;5;28;01melse\u001b[39;00m:\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\indexes\\base.py:7070\u001b[0m, in \u001b[0;36mIndex.drop\u001b[1;34m(self, labels, errors)\u001b[0m\n\u001b[0;32m   7068\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m mask\u001b[38;5;241m.\u001b[39many():\n\u001b[0;32m   7069\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m errors \u001b[38;5;241m!=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mignore\u001b[39m\u001b[38;5;124m\"\u001b[39m:\n\u001b[1;32m-> 7070\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mKeyError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mlabels[mask]\u001b[38;5;241m.\u001b[39mtolist()\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m not found in axis\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m   7071\u001b[0m     indexer \u001b[38;5;241m=\u001b[39m indexer[\u001b[38;5;241m~\u001b[39mmask]\n\u001b[0;32m   7072\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mdelete(indexer)\n",
      "\u001b[1;31mKeyError\u001b[0m: \"['customerID'] not found in axis\""
     ]
    }
   ],
   "source": [
    "daten = daten.drop('customerID', axis=1)\n",
    "daten = daten.drop('RowNumber', axis=1)\n",
    "daten['TotalCharges'] = pd.to_numeric(daten['TotalCharges'], errors='coerce')\n",
    "print(\"\\n--- Fehlende Werte NACH Umwandlung TotalCharges ---\")\n",
    "print(daten.isnull().sum())\n",
    "daten.dropna(inplace=True)\n",
    "daten['Gender'] = daten['Gender'].map({'Female': 0, 'Male': 1})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "64b8a776-6ea8-48a0-841c-38ed7f20e703",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Index(['RowNumber', 'CustomerId', 'Surname', 'CreditScore', 'Geography',\n",
      "       'Gender', 'Age', 'Tenure', 'Balance', 'NumOfProducts', 'HasCrCard',\n",
      "       'IsActiveMember', 'EstimatedSalary', 'Exited', 'Complain',\n",
      "       'Satisfaction Score', 'Card Type', 'Point Earned'],\n",
      "      dtype='object')\n"
     ]
    }
   ],
   "source": [
    "print(daten.columns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "b644c60d-b717-4cac-ba20-ef0a5ecef521",
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyError",
     "evalue": "\"['customerId'] not found in axis\"",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[15], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m daten \u001b[38;5;241m=\u001b[39m daten\u001b[38;5;241m.\u001b[39mdrop(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mcustomerId\u001b[39m\u001b[38;5;124m'\u001b[39m, axis\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m1\u001b[39m)\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\frame.py:5581\u001b[0m, in \u001b[0;36mDataFrame.drop\u001b[1;34m(self, labels, axis, index, columns, level, inplace, errors)\u001b[0m\n\u001b[0;32m   5433\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mdrop\u001b[39m(\n\u001b[0;32m   5434\u001b[0m     \u001b[38;5;28mself\u001b[39m,\n\u001b[0;32m   5435\u001b[0m     labels: IndexLabel \u001b[38;5;241m|\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m,\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m   5442\u001b[0m     errors: IgnoreRaise \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mraise\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m   5443\u001b[0m ) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m DataFrame \u001b[38;5;241m|\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[0;32m   5444\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[0;32m   5445\u001b[0m \u001b[38;5;124;03m    Drop specified labels from rows or columns.\u001b[39;00m\n\u001b[0;32m   5446\u001b[0m \n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m   5579\u001b[0m \u001b[38;5;124;03m            weight  1.0     0.8\u001b[39;00m\n\u001b[0;32m   5580\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n\u001b[1;32m-> 5581\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28msuper\u001b[39m()\u001b[38;5;241m.\u001b[39mdrop(\n\u001b[0;32m   5582\u001b[0m         labels\u001b[38;5;241m=\u001b[39mlabels,\n\u001b[0;32m   5583\u001b[0m         axis\u001b[38;5;241m=\u001b[39maxis,\n\u001b[0;32m   5584\u001b[0m         index\u001b[38;5;241m=\u001b[39mindex,\n\u001b[0;32m   5585\u001b[0m         columns\u001b[38;5;241m=\u001b[39mcolumns,\n\u001b[0;32m   5586\u001b[0m         level\u001b[38;5;241m=\u001b[39mlevel,\n\u001b[0;32m   5587\u001b[0m         inplace\u001b[38;5;241m=\u001b[39minplace,\n\u001b[0;32m   5588\u001b[0m         errors\u001b[38;5;241m=\u001b[39merrors,\n\u001b[0;32m   5589\u001b[0m     )\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\generic.py:4788\u001b[0m, in \u001b[0;36mNDFrame.drop\u001b[1;34m(self, labels, axis, index, columns, level, inplace, errors)\u001b[0m\n\u001b[0;32m   4786\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m axis, labels \u001b[38;5;129;01min\u001b[39;00m axes\u001b[38;5;241m.\u001b[39mitems():\n\u001b[0;32m   4787\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m labels \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[1;32m-> 4788\u001b[0m         obj \u001b[38;5;241m=\u001b[39m obj\u001b[38;5;241m.\u001b[39m_drop_axis(labels, axis, level\u001b[38;5;241m=\u001b[39mlevel, errors\u001b[38;5;241m=\u001b[39merrors)\n\u001b[0;32m   4790\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m inplace:\n\u001b[0;32m   4791\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_update_inplace(obj)\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\generic.py:4830\u001b[0m, in \u001b[0;36mNDFrame._drop_axis\u001b[1;34m(self, labels, axis, level, errors, only_slice)\u001b[0m\n\u001b[0;32m   4828\u001b[0m         new_axis \u001b[38;5;241m=\u001b[39m axis\u001b[38;5;241m.\u001b[39mdrop(labels, level\u001b[38;5;241m=\u001b[39mlevel, errors\u001b[38;5;241m=\u001b[39merrors)\n\u001b[0;32m   4829\u001b[0m     \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m-> 4830\u001b[0m         new_axis \u001b[38;5;241m=\u001b[39m axis\u001b[38;5;241m.\u001b[39mdrop(labels, errors\u001b[38;5;241m=\u001b[39merrors)\n\u001b[0;32m   4831\u001b[0m     indexer \u001b[38;5;241m=\u001b[39m axis\u001b[38;5;241m.\u001b[39mget_indexer(new_axis)\n\u001b[0;32m   4833\u001b[0m \u001b[38;5;66;03m# Case for non-unique axis\u001b[39;00m\n\u001b[0;32m   4834\u001b[0m \u001b[38;5;28;01melse\u001b[39;00m:\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\indexes\\base.py:7070\u001b[0m, in \u001b[0;36mIndex.drop\u001b[1;34m(self, labels, errors)\u001b[0m\n\u001b[0;32m   7068\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m mask\u001b[38;5;241m.\u001b[39many():\n\u001b[0;32m   7069\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m errors \u001b[38;5;241m!=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mignore\u001b[39m\u001b[38;5;124m\"\u001b[39m:\n\u001b[1;32m-> 7070\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mKeyError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mlabels[mask]\u001b[38;5;241m.\u001b[39mtolist()\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m not found in axis\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m   7071\u001b[0m     indexer \u001b[38;5;241m=\u001b[39m indexer[\u001b[38;5;241m~\u001b[39mmask]\n\u001b[0;32m   7072\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mdelete(indexer)\n",
      "\u001b[1;31mKeyError\u001b[0m: \"['customerId'] not found in axis\""
     ]
    }
   ],
   "source": [
    "daten = daten.drop('customerId', axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "d5793535-ea13-49f7-b6d3-74482d6c7813",
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyError",
     "evalue": "\"['CustomerID'] not found in axis\"",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[16], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m daten \u001b[38;5;241m=\u001b[39m daten\u001b[38;5;241m.\u001b[39mdrop(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mCustomerID\u001b[39m\u001b[38;5;124m'\u001b[39m, axis\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m1\u001b[39m)\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\frame.py:5581\u001b[0m, in \u001b[0;36mDataFrame.drop\u001b[1;34m(self, labels, axis, index, columns, level, inplace, errors)\u001b[0m\n\u001b[0;32m   5433\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mdrop\u001b[39m(\n\u001b[0;32m   5434\u001b[0m     \u001b[38;5;28mself\u001b[39m,\n\u001b[0;32m   5435\u001b[0m     labels: IndexLabel \u001b[38;5;241m|\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m,\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m   5442\u001b[0m     errors: IgnoreRaise \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mraise\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m   5443\u001b[0m ) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m DataFrame \u001b[38;5;241m|\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[0;32m   5444\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[0;32m   5445\u001b[0m \u001b[38;5;124;03m    Drop specified labels from rows or columns.\u001b[39;00m\n\u001b[0;32m   5446\u001b[0m \n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m   5579\u001b[0m \u001b[38;5;124;03m            weight  1.0     0.8\u001b[39;00m\n\u001b[0;32m   5580\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n\u001b[1;32m-> 5581\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28msuper\u001b[39m()\u001b[38;5;241m.\u001b[39mdrop(\n\u001b[0;32m   5582\u001b[0m         labels\u001b[38;5;241m=\u001b[39mlabels,\n\u001b[0;32m   5583\u001b[0m         axis\u001b[38;5;241m=\u001b[39maxis,\n\u001b[0;32m   5584\u001b[0m         index\u001b[38;5;241m=\u001b[39mindex,\n\u001b[0;32m   5585\u001b[0m         columns\u001b[38;5;241m=\u001b[39mcolumns,\n\u001b[0;32m   5586\u001b[0m         level\u001b[38;5;241m=\u001b[39mlevel,\n\u001b[0;32m   5587\u001b[0m         inplace\u001b[38;5;241m=\u001b[39minplace,\n\u001b[0;32m   5588\u001b[0m         errors\u001b[38;5;241m=\u001b[39merrors,\n\u001b[0;32m   5589\u001b[0m     )\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\generic.py:4788\u001b[0m, in \u001b[0;36mNDFrame.drop\u001b[1;34m(self, labels, axis, index, columns, level, inplace, errors)\u001b[0m\n\u001b[0;32m   4786\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m axis, labels \u001b[38;5;129;01min\u001b[39;00m axes\u001b[38;5;241m.\u001b[39mitems():\n\u001b[0;32m   4787\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m labels \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[1;32m-> 4788\u001b[0m         obj \u001b[38;5;241m=\u001b[39m obj\u001b[38;5;241m.\u001b[39m_drop_axis(labels, axis, level\u001b[38;5;241m=\u001b[39mlevel, errors\u001b[38;5;241m=\u001b[39merrors)\n\u001b[0;32m   4790\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m inplace:\n\u001b[0;32m   4791\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_update_inplace(obj)\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\generic.py:4830\u001b[0m, in \u001b[0;36mNDFrame._drop_axis\u001b[1;34m(self, labels, axis, level, errors, only_slice)\u001b[0m\n\u001b[0;32m   4828\u001b[0m         new_axis \u001b[38;5;241m=\u001b[39m axis\u001b[38;5;241m.\u001b[39mdrop(labels, level\u001b[38;5;241m=\u001b[39mlevel, errors\u001b[38;5;241m=\u001b[39merrors)\n\u001b[0;32m   4829\u001b[0m     \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m-> 4830\u001b[0m         new_axis \u001b[38;5;241m=\u001b[39m axis\u001b[38;5;241m.\u001b[39mdrop(labels, errors\u001b[38;5;241m=\u001b[39merrors)\n\u001b[0;32m   4831\u001b[0m     indexer \u001b[38;5;241m=\u001b[39m axis\u001b[38;5;241m.\u001b[39mget_indexer(new_axis)\n\u001b[0;32m   4833\u001b[0m \u001b[38;5;66;03m# Case for non-unique axis\u001b[39;00m\n\u001b[0;32m   4834\u001b[0m \u001b[38;5;28;01melse\u001b[39;00m:\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\indexes\\base.py:7070\u001b[0m, in \u001b[0;36mIndex.drop\u001b[1;34m(self, labels, errors)\u001b[0m\n\u001b[0;32m   7068\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m mask\u001b[38;5;241m.\u001b[39many():\n\u001b[0;32m   7069\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m errors \u001b[38;5;241m!=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mignore\u001b[39m\u001b[38;5;124m\"\u001b[39m:\n\u001b[1;32m-> 7070\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mKeyError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mlabels[mask]\u001b[38;5;241m.\u001b[39mtolist()\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m not found in axis\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m   7071\u001b[0m     indexer \u001b[38;5;241m=\u001b[39m indexer[\u001b[38;5;241m~\u001b[39mmask]\n\u001b[0;32m   7072\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mdelete(indexer)\n",
      "\u001b[1;31mKeyError\u001b[0m: \"['CustomerID'] not found in axis\""
     ]
    }
   ],
   "source": [
    "daten = daten.drop('CustomerID', axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "ff7db019-e4c8-4877-aa71-e96d0e3a86ae",
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (3712073613.py, line 1)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;36m  Cell \u001b[1;32mIn[17], line 1\u001b[1;36m\u001b[0m\n\u001b[1;33m    KeyError                                  Traceback (most recent call last)\u001b[0m\n\u001b[1;37m                                              ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "KeyError                                  Traceback (most recent call last)\n",
    "Cell In[16], line 1\n",
    "----> 1 daten = daten.drop('CustomerID', axis=1)\n",
    "\n",
    "File C:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\frame.py:5581, in DataFrame.drop(self, labels, axis, index, columns, level, inplace, errors)\n",
    "   5433 def drop(\n",
    "   5434     self,\n",
    "   5435     labels: IndexLabel | None = None,\n",
    "   (...)\n",
    "   5442     errors: IgnoreRaise = \"raise\",\n",
    "   5443 ) -> DataFrame | None:\n",
    "   5444     \"\"\"\n",
    "   5445     Drop specified labels from rows or columns.\n",
    "   5446 \n",
    "   (...)\n",
    "   5579             weight  1.0     0.8\n",
    "   5580     \"\"\"\n",
    "-> 5581     return super().drop(\n",
    "   5582         labels=labels,\n",
    "   5583         axis=axis,\n",
    "   5584         index=index,\n",
    "   5585         columns=columns,\n",
    "   5586         level=level,\n",
    "   5587         inplace=inplace,\n",
    "   5588         errors=errors,\n",
    "   5589     )\n",
    "\n",
    "File C:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\generic.py:4788, in NDFrame.drop(self, labels, axis, index, columns, level, inplace, errors)\n",
    "   4786 for axis, labels in axes.items():\n",
    "   4787     if labels is not None:\n",
    "-> 4788         obj = obj._drop_axis(labels, axis, level=level, errors=errors)\n",
    "   4790 if inplace:\n",
    "   4791     self._update_inplace(obj)\n",
    "\n",
    "File C:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\generic.py:4830, in NDFrame._drop_axis(self, labels, axis, level, errors, only_slice)\n",
    "   4828         new_axis = axis.drop(labels, level=level, errors=errors)\n",
    "   4829     else:\n",
    "-> 4830         new_axis = axis.drop(labels, errors=errors)\n",
    "   4831     indexer = axis.get_indexer(new_axis)\n",
    "   4833 # Case for non-unique axis\n",
    "   4834 else:\n",
    "\n",
    "File C:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\indexes\\base.py:7070, in Index.drop(self, labels, errors)\n",
    "   7068 if mask.any():\n",
    "   7069     if errors != \"ignore\":\n",
    "-> 7070         raise KeyError(f\"{labels[mask].tolist()} not found in axis\")\n",
    "   7071     indexer = indexer[~mask]\n",
    "   7072 return self.delete(indexer)\n",
    "\n",
    "KeyError: \"['CustomerID'] not found in axis\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "7b1cba2d-6337-440a-afbd-a25a7d018d78",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Index(['RowNumber', 'CustomerId', 'Surname', 'CreditScore', 'Geography',\n",
      "       'Gender', 'Age', 'Tenure', 'Balance', 'NumOfProducts', 'HasCrCard',\n",
      "       'IsActiveMember', 'EstimatedSalary', 'Exited', 'Complain',\n",
      "       'Satisfaction Score', 'Card Type', 'Point Earned'],\n",
      "      dtype='object')\n"
     ]
    }
   ],
   "source": [
    "print(daten.columns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "d0bb98f1-e94e-439b-bd9d-a9208404cec7",
   "metadata": {},
   "outputs": [],
   "source": [
    "daten = daten.drop(['RowNumber', 'CustomerId', 'Surname'], axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "21c8d1db-dd49-44a9-ba47-9cdc8bee2ea6",
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyError",
     "evalue": "'TotalCharges'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\indexes\\base.py:3805\u001b[0m, in \u001b[0;36mIndex.get_loc\u001b[1;34m(self, key)\u001b[0m\n\u001b[0;32m   3804\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[1;32m-> 3805\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_engine\u001b[38;5;241m.\u001b[39mget_loc(casted_key)\n\u001b[0;32m   3806\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mKeyError\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m err:\n",
      "File \u001b[1;32mindex.pyx:167\u001b[0m, in \u001b[0;36mpandas._libs.index.IndexEngine.get_loc\u001b[1;34m()\u001b[0m\n",
      "File \u001b[1;32mindex.pyx:196\u001b[0m, in \u001b[0;36mpandas._libs.index.IndexEngine.get_loc\u001b[1;34m()\u001b[0m\n",
      "File \u001b[1;32mpandas\\\\_libs\\\\hashtable_class_helper.pxi:7081\u001b[0m, in \u001b[0;36mpandas._libs.hashtable.PyObjectHashTable.get_item\u001b[1;34m()\u001b[0m\n",
      "File \u001b[1;32mpandas\\\\_libs\\\\hashtable_class_helper.pxi:7089\u001b[0m, in \u001b[0;36mpandas._libs.hashtable.PyObjectHashTable.get_item\u001b[1;34m()\u001b[0m\n",
      "\u001b[1;31mKeyError\u001b[0m: 'TotalCharges'",
      "\nThe above exception was the direct cause of the following exception:\n",
      "\u001b[1;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[20], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m daten[\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mTotalCharges\u001b[39m\u001b[38;5;124m'\u001b[39m] \u001b[38;5;241m=\u001b[39m pd\u001b[38;5;241m.\u001b[39mto_numeric(daten[\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mTotalCharges\u001b[39m\u001b[38;5;124m'\u001b[39m], errors\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mcoerce\u001b[39m\u001b[38;5;124m'\u001b[39m)\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\frame.py:4102\u001b[0m, in \u001b[0;36mDataFrame.__getitem__\u001b[1;34m(self, key)\u001b[0m\n\u001b[0;32m   4100\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mcolumns\u001b[38;5;241m.\u001b[39mnlevels \u001b[38;5;241m>\u001b[39m \u001b[38;5;241m1\u001b[39m:\n\u001b[0;32m   4101\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_getitem_multilevel(key)\n\u001b[1;32m-> 4102\u001b[0m indexer \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mcolumns\u001b[38;5;241m.\u001b[39mget_loc(key)\n\u001b[0;32m   4103\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m is_integer(indexer):\n\u001b[0;32m   4104\u001b[0m     indexer \u001b[38;5;241m=\u001b[39m [indexer]\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\pandas\\core\\indexes\\base.py:3812\u001b[0m, in \u001b[0;36mIndex.get_loc\u001b[1;34m(self, key)\u001b[0m\n\u001b[0;32m   3807\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(casted_key, \u001b[38;5;28mslice\u001b[39m) \u001b[38;5;129;01mor\u001b[39;00m (\n\u001b[0;32m   3808\u001b[0m         \u001b[38;5;28misinstance\u001b[39m(casted_key, abc\u001b[38;5;241m.\u001b[39mIterable)\n\u001b[0;32m   3809\u001b[0m         \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28many\u001b[39m(\u001b[38;5;28misinstance\u001b[39m(x, \u001b[38;5;28mslice\u001b[39m) \u001b[38;5;28;01mfor\u001b[39;00m x \u001b[38;5;129;01min\u001b[39;00m casted_key)\n\u001b[0;32m   3810\u001b[0m     ):\n\u001b[0;32m   3811\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m InvalidIndexError(key)\n\u001b[1;32m-> 3812\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mKeyError\u001b[39;00m(key) \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01merr\u001b[39;00m\n\u001b[0;32m   3813\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mTypeError\u001b[39;00m:\n\u001b[0;32m   3814\u001b[0m     \u001b[38;5;66;03m# If we have a listlike key, _check_indexing_error will raise\u001b[39;00m\n\u001b[0;32m   3815\u001b[0m     \u001b[38;5;66;03m#  InvalidIndexError. Otherwise we fall through and re-raise\u001b[39;00m\n\u001b[0;32m   3816\u001b[0m     \u001b[38;5;66;03m#  the TypeError.\u001b[39;00m\n\u001b[0;32m   3817\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_check_indexing_error(key)\n",
      "\u001b[1;31mKeyError\u001b[0m: 'TotalCharges'"
     ]
    }
   ],
   "source": [
    "daten['TotalCharges'] = pd.to_numeric(daten['TotalCharges'], errors='coerce')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "86b2175b-c155-4e6f-bc1a-f76db58e1521",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--- Aktuelle Spaltennamen nach dem Entfernen von RowNumber, CustomerId, Surname ---\n",
      "Index(['CreditScore', 'Geography', 'Gender', 'Age', 'Tenure', 'Balance',\n",
      "       'NumOfProducts', 'HasCrCard', 'IsActiveMember', 'EstimatedSalary',\n",
      "       'Exited', 'Complain', 'Satisfaction Score', 'Card Type',\n",
      "       'Point Earned'],\n",
      "      dtype='object')\n"
     ]
    }
   ],
   "source": [
    "dateipfad = r\"C:\\Users\\TN1\\Downloads\\Customer-Churn-Records.csv\"\n",
    "daten = pd.read_csv(dateipfad)\n",
    "daten = daten.drop(['RowNumber', 'CustomerId', 'Surname'], axis=1)\n",
    "print(\"--- Aktuelle Spaltennamen nach dem Entfernen von RowNumber, CustomerId, Surname ---\")\n",
    "print(daten.columns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "1cf68336-a5ae-44af-b8b4-c15423d6a5d2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Fehlende Werte NACH aller Bereinigung und Umwandlung ---\n",
      "CreditScore           0\n",
      "Gender                0\n",
      "Age                   0\n",
      "Tenure                0\n",
      "Balance               0\n",
      "NumOfProducts         0\n",
      "HasCrCard             0\n",
      "IsActiveMember        0\n",
      "EstimatedSalary       0\n",
      "Exited                0\n",
      "Complain              0\n",
      "Satisfaction Score    0\n",
      "Point Earned          0\n",
      "Geography_Germany     0\n",
      "Geography_Spain       0\n",
      "Card Type_GOLD        0\n",
      "Card Type_PLATINUM    0\n",
      "Card Type_SILVER      0\n",
      "dtype: int64\n",
      "\n",
      "--- Daten nach der Bereinigung und Umwandlung (erste 5 Zeilen) ---\n",
      "   CreditScore  Gender  Age  Tenure    Balance  NumOfProducts  HasCrCard  \\\n",
      "0          619       0   42       2       0.00              1          1   \n",
      "1          608       0   41       1   83807.86              1          0   \n",
      "2          502       0   42       8  159660.80              3          1   \n",
      "3          699       0   39       1       0.00              2          0   \n",
      "4          850       0   43       2  125510.82              1          1   \n",
      "\n",
      "   IsActiveMember  EstimatedSalary  Exited  Complain  Satisfaction Score  \\\n",
      "0               1        101348.88       1         1                   2   \n",
      "1               1        112542.58       0         1                   3   \n",
      "2               0        113931.57       1         1                   3   \n",
      "3               0         93826.63       0         0                   5   \n",
      "4               1         79084.10       0         0                   5   \n",
      "\n",
      "   Point Earned  Geography_Germany  Geography_Spain  Card Type_GOLD  \\\n",
      "0           464              False            False           False   \n",
      "1           456              False             True           False   \n",
      "2           377              False            False           False   \n",
      "3           350              False            False            True   \n",
      "4           425              False             True            True   \n",
      "\n",
      "   Card Type_PLATINUM  Card Type_SILVER  \n",
      "0               False             False  \n",
      "1               False             False  \n",
      "2               False             False  \n",
      "3               False             False  \n",
      "4               False             False  \n",
      "\n",
      "--- Daten-Info nach der Bereinigung ---\n",
      "<class 'pandas.core.frame.DataFrame'>\n",
      "RangeIndex: 10000 entries, 0 to 9999\n",
      "Data columns (total 18 columns):\n",
      " #   Column              Non-Null Count  Dtype  \n",
      "---  ------              --------------  -----  \n",
      " 0   CreditScore         10000 non-null  int64  \n",
      " 1   Gender              10000 non-null  int64  \n",
      " 2   Age                 10000 non-null  int64  \n",
      " 3   Tenure              10000 non-null  int64  \n",
      " 4   Balance             10000 non-null  float64\n",
      " 5   NumOfProducts       10000 non-null  int64  \n",
      " 6   HasCrCard           10000 non-null  int64  \n",
      " 7   IsActiveMember      10000 non-null  int64  \n",
      " 8   EstimatedSalary     10000 non-null  float64\n",
      " 9   Exited              10000 non-null  int64  \n",
      " 10  Complain            10000 non-null  int64  \n",
      " 11  Satisfaction Score  10000 non-null  int64  \n",
      " 12  Point Earned        10000 non-null  int64  \n",
      " 13  Geography_Germany   10000 non-null  bool   \n",
      " 14  Geography_Spain     10000 non-null  bool   \n",
      " 15  Card Type_GOLD      10000 non-null  bool   \n",
      " 16  Card Type_PLATINUM  10000 non-null  bool   \n",
      " 17  Card Type_SILVER    10000 non-null  bool   \n",
      "dtypes: bool(5), float64(2), int64(11)\n",
      "memory usage: 1.0 MB\n"
     ]
    }
   ],
   "source": [
    "# 1. Wir haben bereits die nicht benötigten Spalten entfernt (RowNumber, CustomerId, Surname).\n",
    "#    Jetzt überspringen wir den 'TotalCharges'-Schritt, da die Spalte nicht existiert.\n",
    "\n",
    "# 2. Text-Spalten (kategorische Daten) in Zahlen umwandeln\n",
    "\n",
    "# Für 'Gender': 'Female' wird zu 0 und 'Male' zu 1\n",
    "# Das hatten wir schon besprochen, und es ist in deiner Liste.\n",
    "daten['Gender'] = daten['Gender'].map({'Female': 0, 'Male': 1})\n",
    "\n",
    "\n",
    "# Für andere Textspalten mit mehreren verschiedenen Werten (One-Hot Encoding).\n",
    "# Das sind die Spalten, die in deiner Liste der Spaltennamen als Text (object) aufgeführt sind\n",
    "# und die mehr als nur zwei (Ja/Nein) Werte haben.\n",
    "# Aus deiner Spaltenliste scheinen das 'Geography' und 'Card Type' zu sein.\n",
    "# Überprüfe im Zweifel mit daten['Geography'].value_counts() oder daten['Card Type'].value_counts()\n",
    "# ob es wirklich mehrere einzigartige Werte gibt.\n",
    "text_spalten_zum_umwandeln = ['Geography', 'Card Type']\n",
    "\n",
    "# 'drop_first=True' ist gut, um eine Spalte pro Kategorie zu sparen.\n",
    "daten = pd.get_dummies(daten, columns=text_spalten_zum_umwandeln, drop_first=True)\n",
    "\n",
    "\n",
    "# 3. Überprüfen, ob noch fehlende Werte vorhanden sind\n",
    "# Nach den drops und get_dummies sollte hier idealerweise alles 0 sein.\n",
    "# Wenn hier noch etwas auftaucht, müssten wir das spezifisch adressieren.\n",
    "print(\"\\n--- Fehlende Werte NACH aller Bereinigung und Umwandlung ---\")\n",
    "print(daten.isnull().sum())\n",
    "\n",
    "# Nur um sicherzugehen, dass keine Zeilen mehr mit NaN übrig sind, falls doch welche entstanden sind.\n",
    "# Dies sollte nach der vorherigen Prüfung eigentlich nicht mehr nötig sein, schadet aber nicht.\n",
    "daten.dropna(inplace=True)\n",
    "\n",
    "\n",
    "# 4. Zeige die ersten paar Zeilen NACH allen Bereinigungen an\n",
    "print(\"\\n--- Daten nach der Bereinigung und Umwandlung (erste 5 Zeilen) ---\")\n",
    "print(daten.head())\n",
    "\n",
    "# 5. Und nochmal die Info, um zu sehen, ob alles Zahlen sind und keine fehlenden Werte mehr da sind\n",
    "print(\"\\n--- Daten-Info nach der Bereinigung ---\")\n",
    "daten.info()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "0a73d0eb-844d-4e3a-b524-cafccbbc1371",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Daten erfolgreich in Trainings- und Teststapel aufgeteilt:\n",
      "Trainingsdaten für Hinweise (X_train): (8000, 17)\n",
      "Testdaten für Hinweise (X_test): (2000, 17)\n",
      "Trainingsdaten für Antwort (y_train): (8000,)\n",
      "Testdaten für Antwort (y_test): (2000,)\n",
      "\n",
      "Modell (Kunden-Abwanderungs-Radar) erfolgreich trainiert!\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\ProgramData\\anaconda3\\Lib\\site-packages\\sklearn\\linear_model\\_logistic.py:465: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n"
     ]
    }
   ],
   "source": [
    "from sklearn.model_selection import train_test_split # Werkzeug zum Aufteilen der Daten\n",
    "from sklearn.linear_model import LogisticRegression   # Unser erster \"Detektiv-Algorithmus\" (Modell)\n",
    "from sklearn.metrics import accuracy_score, classification_report, confusion_matrix # Werkzeuge zum Bewerten\n",
    "\n",
    "# 1. Trenne die \"Hinweise\" (X) von der \"Antwort\" (y)\n",
    "# 'Exited' ist die Spalte, die sagt, ob der Kunde abgewandert ist (1) oder nicht (0).\n",
    "# Wir nehmen alle anderen Spalten als unsere Hinweise (Features).\n",
    "X = daten.drop('Exited', axis=1) # Alle Spalten außer 'Exited' sind unsere Hinweise\n",
    "y = daten['Exited']              # 'Exited' ist unsere Antwort\n",
    "\n",
    "# 2. Teile die Daten in zwei Stapel auf: Trainingsdaten und Testdaten\n",
    "# Trainingsdaten (80%): Damit lernt unser Detektiv.\n",
    "# Testdaten (20%): Damit prüfen wir, wie gut er gelernt hat, mit neuen, ungesehenen Daten.\n",
    "# random_state=42 ist wie ein Zauberwürfel-Seed: Es sorgt dafür, dass die Aufteilung jedes Mal gleich ist,\n",
    "# damit wir unsere Ergebnisse vergleichen können, wenn wir es nochmal ausführen.\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
    "\n",
    "print(\"Daten erfolgreich in Trainings- und Teststapel aufgeteilt:\")\n",
    "print(f\"Trainingsdaten für Hinweise (X_train): {X_train.shape}\")\n",
    "print(f\"Testdaten für Hinweise (X_test): {X_test.shape}\")\n",
    "print(f\"Trainingsdaten für Antwort (y_train): {y_train.shape}\")\n",
    "print(f\"Testdaten für Antwort (y_test): {y_test.shape}\")\n",
    "\n",
    "\n",
    "# 3. Den Detektiv-Algorithmus auswählen und trainieren\n",
    "# Logistic Regression ist ein guter Start-Algorithmus für Vorhersagen, ob etwas Ja/Nein ist.\n",
    "# max_iter=1000 sorgt dafür, dass der Algorithmus genug Zeit hat, zu lernen.\n",
    "mein_radar = LogisticRegression(max_iter=1000)\n",
    "\n",
    "# Hier lernt der Detektiv! Er schaut sich X_train (Hinweise) an und vergleicht sie mit y_train (Antworten).\n",
    "mein_radar.fit(X_train, y_train)\n",
    "\n",
    "print(\"\\nModell (Kunden-Abwanderungs-Radar) erfolgreich trainiert!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "0948bd0b-22a6-4435-bcb7-25643b0d3ee9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Genauigkeit des Kunden-Abwanderungs-Radars: 1.00\n",
      "\n",
      "--- Ausführlicher Bericht (Classification Report) ---\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "           0       1.00      1.00      1.00      1607\n",
      "           1       1.00      0.99      1.00       393\n",
      "\n",
      "    accuracy                           1.00      2000\n",
      "   macro avg       1.00      1.00      1.00      2000\n",
      "weighted avg       1.00      1.00      1.00      2000\n",
      "\n",
      "\n",
      "--- Verwirrungs-Matrix (Confusion Matrix) ---\n",
      "[[1606    1]\n",
      " [   2  391]]\n"
     ]
    }
   ],
   "source": [
    "# 1. Der Detektiv macht Vorhersagen für die Testdaten\n",
    "# predict() sagt uns für jeden Kunden in X_test, ob er abwandern wird (1) oder nicht (0).\n",
    "vorhersagen = mein_radar.predict(X_test)\n",
    "\n",
    "# 2. Wie oft lag er richtig? (Die Genauigkeit)\n",
    "# accuracy_score vergleicht unsere Vorhersagen (vorhersagen) mit den echten Antworten (y_test).\n",
    "genauigkeit = accuracy_score(y_test, vorhersagen)\n",
    "print(f'Genauigkeit des Kunden-Abwanderungs-Radars: {genauigkeit:.2f}') # Zeigt die Genauigkeit als Prozent (z.B. 0.85 für 85%)\n",
    "\n",
    "# 3. Ein detaillierter Bericht (wichtiger für Detektive!)\n",
    "# Dieser Bericht (classification_report) zeigt uns genauer, wie gut das Modell für beide Gruppen ist:\n",
    "# - Wie gut erkennt es Kunden, die WIRKLICH abwandern (Klasse 1)?\n",
    "# - Wie gut erkennt es Kunden, die NICHT abwandern (Klasse 0)?\n",
    "# Die Metriken \"precision\", \"recall\" und \"f1-score\" sind hier wichtig und aussagekräftiger als nur die Genauigkeit.\n",
    "print('\\n--- Ausführlicher Bericht (Classification Report) ---')\n",
    "print(classification_report(y_test, vorhersagen))\n",
    "\n",
    "# 4. Die Verwirrungs-Matrix (Confusion Matrix)\n",
    "# Sieht kompliziert aus, aber ist super zum Verstehen!\n",
    "# Sie zeigt uns, wie oft unser Radar richtig und falsch lag, aufgeteilt:\n",
    "# - True Negatives (TN): Richtig vorhergesagt, dass jemand NICHT abwandert (oben links)\n",
    "# - False Positives (FP): Falsch vorhergesagt, dass jemand abwandert, obwohl er BLEIBT (oben rechts)\n",
    "# - False Negatives (FN): Falsch vorhergesagt, dass jemand BLEIBT, obwohl er ABWANDERT (unten links - SEHR WICHTIG!)\n",
    "# - True Positives (TP): Richtig vorhergesagt, dass jemand ABWANDERT (unten rechts)\n",
    "print('\\n--- Verwirrungs-Matrix (Confusion Matrix) ---')\n",
    "print(confusion_matrix(y_test, vorhersagen))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "493f5ab1-d765-4cc3-8612-3f1f6b9fadd1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Daten erfolgreich in Trainings- und Teststapel aufgeteilt (nach Beseitigung des Lecks):\n",
      "Trainingsdaten für Hinweise (X_train): (8000, 15)\n",
      "Testdaten für Hinweise (X_test): (2000, 15)\n",
      "\n",
      "Modell (Kunden-Abwanderungs-Radar) erfolgreich NEU trainiert!\n",
      "\n",
      "Genauigkeit des NEUEN Kunden-Abwanderungs-Radars: 0.81\n",
      "\n",
      "--- Ausführlicher Bericht (Classification Report) ---\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "           0       0.83      0.96      0.89      1607\n",
      "           1       0.58      0.22      0.31       393\n",
      "\n",
      "    accuracy                           0.81      2000\n",
      "   macro avg       0.71      0.59      0.60      2000\n",
      "weighted avg       0.78      0.81      0.78      2000\n",
      "\n",
      "\n",
      "--- Verwirrungs-Matrix (Confusion Matrix) ---\n",
      "[[1545   62]\n",
      " [ 308   85]]\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\ProgramData\\anaconda3\\Lib\\site-packages\\sklearn\\linear_model\\_logistic.py:465: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n"
     ]
    }
   ],
   "source": [
    "# 1. Trenne die \"Hinweise\" (X) von der \"Antwort\" (y)\n",
    "# Wir entfernen diesmal 'Complain' und 'Satisfaction Score' zusätzlich zu 'Exited'.\n",
    "# Diese Spalten könnten ein \"Datenleck\" verursachen, weil sie die Abwanderung zu direkt widerspiegeln.\n",
    "# Das ist wie, wenn der Detektiv schon die Lösung bekommt, bevor er anfängt zu suchen.\n",
    "X = daten.drop(['Exited', 'Complain', 'Satisfaction Score'], axis=1)\n",
    "y = daten['Exited']\n",
    "\n",
    "# 2. Teile die Daten erneut in Trainings- und Teststapel auf\n",
    "# (Wiederholung, um sicherzustellen, dass die neue X-Variable verwendet wird)\n",
    "from sklearn.model_selection import train_test_split\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
    "\n",
    "print(\"Daten erfolgreich in Trainings- und Teststapel aufgeteilt (nach Beseitigung des Lecks):\")\n",
    "print(f\"Trainingsdaten für Hinweise (X_train): {X_train.shape}\")\n",
    "print(f\"Testdaten für Hinweise (X_test): {X_test.shape}\")\n",
    "\n",
    "# 3. Den Detektiv-Algorithmus erneut trainieren\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "mein_radar = LogisticRegression(max_iter=1000) # Die Warnung von vorher ist OK für jetzt\n",
    "mein_radar.fit(X_train, y_train)\n",
    "\n",
    "print(\"\\nModell (Kunden-Abwanderungs-Radar) erfolgreich NEU trainiert!\")\n",
    "\n",
    "# 4. Leistung des NEUEN Detektivs bewerten\n",
    "from sklearn.metrics import accuracy_score, classification_report, confusion_matrix\n",
    "\n",
    "vorhersagen = mein_radar.predict(X_test)\n",
    "\n",
    "genauigkeit = accuracy_score(y_test, vorhersagen)\n",
    "print(f'\\nGenauigkeit des NEUEN Kunden-Abwanderungs-Radars: {genauigkeit:.2f}')\n",
    "\n",
    "print('\\n--- Ausführlicher Bericht (Classification Report) ---')\n",
    "print(classification_report(y_test, vorhersagen))\n",
    "\n",
    "print('\\n--- Verwirrungs-Matrix (Confusion Matrix) ---')\n",
    "print(confusion_matrix(y_test, vorhersagen))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "689ad4d7-bbc9-4a6c-ac4e-4510631f301d",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
